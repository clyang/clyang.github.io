<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>clyang的技術筆記</title>
  <subtitle>隨手亂記</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.clyang.net/"/>
  <updated>2017-08-20T08:10:05.844Z</updated>
  <id>http://blog.clyang.net/</id>
  
  <author>
    <name>clyang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>網路測速小技巧：使用aria2c</title>
    <link href="http://blog.clyang.net/2017/08/19/aria2c-speed-test-tip/"/>
    <id>http://blog.clyang.net/2017/08/19/aria2c-speed-test-tip/</id>
    <published>2017-08-19T23:26:29.000Z</published>
    <updated>2017-08-20T08:10:05.844Z</updated>
    
    <content type="html"><![CDATA[<p>我是個喜歡測試網路速度的無聊人，<a href="http://beta.speedtest.net/" target="_blank" rel="external">Speedtest.net</a>雖然方便但沒辦法提供多線+大檔案(e.g 10GB以上的大小)的長時間測試，所以就想到<a href="https://aria2.github.io/" target="_blank" rel="external"><code>aria2c</code></a>這個在cli下的的多線下載軟體，不過我又不想實際把檔案寫入硬碟上 (尤其這年頭大家都用SSD，為了測試寫10G的資料實在很傷啊)，所以研究了一下，湊出了以下的解法。 <strong>注意！此方法僅適用於Unix或MacOS</strong><br><a id="more"></a><br>如果你的電腦還沒有安裝<a href="https://aria2.github.io/" target="_blank" rel="external"><code>aria2c</code></a>，請先自行安裝好，然後輸入以下指令即可讓你同時16線抓取遠端的一個大檔而且不會將檔案實際寫入磁碟中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 抓取一個1.5G的iso檔</div><div class="line">aria2c -d /dev -o null --allow-overwrite=true -x 16 -s 16 --file-allocation=none --summary-interval=0 http://tw.archive.ubuntu.com/ubuntu-cd/17.04/ubuntu-17.04-desktop-amd64.iso</div></pre></td></tr></table></figure>
<p>附上各個參數的說明給好奇的你：</p>
<ul>
<li><code>-d /dev</code> : 將檔案輸出至/dev中</li>
<li><code>-o null</code> : 將檔案命名為null</li>
<li><code>--allow-overwrite=true</code> : 如果磁碟上有同樣名稱的檔案，允許直接覆蓋過去</li>
<li><code>-x 16</code> : 把單一server允許建立的連線數從1個增加為16個</li>
<li><code>-s 16</code> : 指定用要16個connection同時下載單一檔案，預設是5</li>
<li><code>--file-allocation=none</code> : 不需先allocate磁碟空間</li>
<li><code>--summary-interval=0</code> : 不要每個一陣子就顯示summary</li>
</ul>
<p>全部結合在一起後的效果，用白話文來說就是:</p>
<blockquote>
<p>幫我把某個url的檔案用16線給我抓回來，寫進去/dev/null裡面，如果/dev/null已經存在，不要理他，硬寫進去即可，然後也不用幫我在磁碟上取得一塊空間，而且summary看了很煩，所以也不用顯示了。</p>
</blockquote>
<p>透過這方式你就可以指定一個超大的檔案來測試一下你的ISP連外速度的穩定度啦！</p>
<p>最後小bouns，附上一些超過10GB的測速檔案給愛測速的你 kerker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">http://download.xs4all.nl/test/10GB.bin</div><div class="line">http://lg-tor.fdcservers.net/10GBtest.zip</div><div class="line">http://lg.ams2-c.fdcservers.net/10GBtest.zip</div><div class="line">http://lg.chi2-c.fdcservers.net/10GBtest.zip</div><div class="line">http://lg.den2-c.fdcservers.net/10GBtest.zip</div><div class="line">http://lg.fra2-c.fdcservers.net/10GBtest.zip</div><div class="line">http://lg.la2-c.fdcservers.net/10GBtest.zip</div><div class="line">http://lg.lon-c.fdcservers.net/10GBtest.zip</div><div class="line">http://lg.mad-c.fdcservers.net/10GBtest.zip</div><div class="line">http://lg.mia-c.fdcservers.net/10GBtest.zip</div><div class="line">http://lg.ny-z.fdcservers.net/10GBtest.zip</div><div class="line">http://lg.par-c.fdcservers.net/10GBtest.zip</div><div class="line">http://lg.sea-z.fdcservers.net/10GBtest.zip</div><div class="line">http://lg.vie-c.fdcservers.net/10GBtest.zip</div><div class="line">http://mirror.filearena.net/pub/speed/SpeedTest_2048MB.dat</div><div class="line">http://mirror.i3d.net/10000mb.bin</div><div class="line">http://mirror.nl.leaseweb.net/speedtest/10000mb.bin</div><div class="line">http://mirror.us.leaseweb.net/speedtest/10000mb.bin</div><div class="line">http://mirror.widexs.nl/ftp/pub/speed/10000mb.bin</div><div class="line">http://mirrors-lax.webnx.com/test/10gb.bin</div><div class="line">http://nl.altushost.com/10gb.test</div><div class="line">http://ping6.online.net/10000Mo.dat</div><div class="line">http://proof.ovh.ca/files/10Gio.dat</div><div class="line">http://proof.ovh.net/files/10Gio.dat</div><div class="line">http://repos.lax-noc.com/speedtests/100gb.bin</div><div class="line">http://repos.mia.lax-noc.com/speedtests/100gb.bin</div><div class="line">http://speed.hetzner.de/10GB.bin</div><div class="line">http://speedtest.belwue.net/100G</div><div class="line">http://speedtest.serverius.net/files/10000mb.bin</div><div class="line">http://speedtest.sjc01.softlayer.com/downloads/test10000.zip</div><div class="line">http://speedtest.wdc01.softlayer.com/downloads/test10000.zip</div><div class="line">http://speedtest6.tele2.net/100GB.zip</div><div class="line">https://speed.hostkey.ru/ftp/10000mb.bin</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是個喜歡測試網路速度的無聊人，&lt;a href=&quot;http://beta.speedtest.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Speedtest.net&lt;/a&gt;雖然方便但沒辦法提供多線+大檔案(e.g 10GB以上的大小)的長時間測試，所以就想到&lt;a href=&quot;https://aria2.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;aria2c&lt;/code&gt;&lt;/a&gt;這個在cli下的的多線下載軟體，不過我又不想實際把檔案寫入硬碟上 (尤其這年頭大家都用SSD，為了測試寫10G的資料實在很傷啊)，所以研究了一下，湊出了以下的解法。 &lt;strong&gt;注意！此方法僅適用於Unix或MacOS&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="aria2c" scheme="http://blog.clyang.net/tags/aria2c/"/>
    
      <category term="speedtest" scheme="http://blog.clyang.net/tags/speedtest/"/>
    
      <category term="網路技術" scheme="http://blog.clyang.net/tags/%E7%B6%B2%E8%B7%AF%E6%8A%80%E8%A1%93/"/>
    
  </entry>
  
  <entry>
    <title>使用HTTP 204狀態碼來節省API的頻寬用量</title>
    <link href="http://blog.clyang.net/2017/08/18/use-http-204-reduce-bandwidth/"/>
    <id>http://blog.clyang.net/2017/08/18/use-http-204-reduce-bandwidth/</id>
    <published>2017-08-18T06:42:57.000Z</published>
    <updated>2017-08-18T16:29:07.066Z</updated>
    
    <content type="html"><![CDATA[<p>找資料時發現一篇有趣的技術文，是由<a href="https://www.stathat.com/" target="_blank" rel="external">StatHat</a>所撰寫的「<a href="https://blog.stathat.com/2017/05/05/bandwidth.html" target="_blank" rel="external">83% Bandwidth Reduction via API ResponseChange</a>」。<br><a id="more"></a><br>原理其實相當簡單，一般在設計RESTful API時，最常見的作法就是回傳一個json，裡面通常都會包涵執行結果的狀態碼以及錯誤說明，譬如說下方這個回傳執行成功的範例，包含http header也只有152 bytes。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Content-Type: application/json</div><div class="line">Date: Tue, 02 May 2017 14:53:45 GMT</div><div class="line">Content-Length: 25</div><div class="line">Connection: keep-alive</div><div class="line"></div><div class="line">&#123;&quot;status&quot;:200,&quot;msg&quot;:&quot;ok&quot;&#125;</div></pre></td></tr></table></figure>
<p>但是當你的量大到像是<a href="https://www.stathat.com/" target="_blank" rel="external">StatHat</a>，每個月有多達1,500億則request，既使每則request都執行成功而回應上面的json，也會使用超過20TB的量 (更別提如果執行失敗，<code>msg</code>還會帶一些說明而佔用更多bytes)。</p>
<p>在實際使用情境下，絕大多數的request都是正常的執行，他們開始研究要怎麼樣能夠用最少的資料量讓使用者得知他們的request已經成功被執行，再參考<a href="https://tools.ietf.org/html/rfc7231" target="_blank" rel="external">RFC-7231</a>後，他們看到了一個常常被遺忘的http狀態碼: <code>204</code>，根據<a href="https://tools.ietf.org/html/rfc7231" target="_blank" rel="external">RFC-7231</a>，他的定義是</p>
<blockquote>
<p>The 204 (No Content) status code indicates that the server has successfully fulfilled the request and that there is no additional content to send in the response payload body.</p>
<p>翻成白話文就是：如果client收到http 204 status code就表示你送出的request有成功的被滿足，句點！沒有其他廢話！</p>
</blockquote>
<p>於是乎，回傳的http header變成只有25 bytes，省下了大概125 bytes！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 204 No Content</div></pre></td></tr></table></figure>
<p>根據<a href="https://www.stathat.com/" target="_blank" rel="external">StatHat</a>的觀察，這樣的改變每個月幫他們省下了大概17TB的流量，相當驚人吧！</p>
<p>結論：你得先有如此大的量才需要考慮從http response code來省流量，kerker</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;找資料時發現一篇有趣的技術文，是由&lt;a href=&quot;https://www.stathat.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;StatHat&lt;/a&gt;所撰寫的「&lt;a href=&quot;https://blog.stathat.com/2017/05/05/bandwidth.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;83% Bandwidth Reduction via API ResponseChange&lt;/a&gt;」。&lt;br&gt;
    
    </summary>
    
    
      <category term="網路技術" scheme="http://blog.clyang.net/tags/%E7%B6%B2%E8%B7%AF%E6%8A%80%E8%A1%93/"/>
    
      <category term="http 204" scheme="http://blog.clyang.net/tags/http-204/"/>
    
  </entry>
  
  <entry>
    <title>非固定制Hinet IPv6 Dual Stack在Ubiquiti Edgerouter上Prefix的更新問題</title>
    <link href="http://blog.clyang.net/2017/08/16/edgerouter-ipv6-prefix-issue/"/>
    <id>http://blog.clyang.net/2017/08/16/edgerouter-ipv6-prefix-issue/</id>
    <published>2017-08-16T04:49:04.000Z</published>
    <updated>2017-08-18T14:03:38.947Z</updated>
    
    <content type="html"><![CDATA[<h3 id="症狀"><a href="#症狀" class="headerlink" title="症狀"></a>症狀</h3><p>使用Hinet非固定制方案並且有申請IPv6 Dual Stack的使用者，透過Edgerouter當作分享器時，串在Edgerouter後的電腦如果長期不關機，會碰到當Hinet強制斷線時重撥後，這些電腦雖然可以取得新的IPv6位置，但卻喪失所有的IPv6連線能力。<br><a id="more"></a></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在mac上觀察了一下，發現即使已經取得了新的IPv6位置，電腦依舊是使用重撥前的IPv6位置當做第一優先，所以全部的IPv6連線在Hinet重撥後都無法成功建立，於是ssh連進Edgerouter-X使用<code>radvdump</code>觀察router advertisement (RA)的狀況，發現Edgerouter-X依舊在advertise舊的IPv6 Prefix，透過<code>show interfaces</code>發現<code>switch0</code>上面綁著數個之前取得的IPv6 Prefix而沒有被清除掉，而<code>radvd</code>單純只看<code>switch0</code>上綁的IPv6位置來產生RA，導致接受到RA的電腦認為RA中的Prefix都是有效的，即使有取得新的IPv6位置，但MacOS或Windows在這樣的情下，皆會優先使用先前已生效的IPv6位置，所以導致連線失效。</p>
<p>知道原因後，就容易解決了，只需要在每次PPPoE斷線後，把綁在<code>switch0</code>上的IPv6位置清除，當PPPoE重新連上取得新的IPv6位置後，<code>radvd</code>只會看到最新的IPv6位置，也就不會繼續advertise舊的Prefix，而在電腦端(無論是MacOS或Windows)，則會因為只接受到新的Prefix而認為先前的IPv6位置已經失效，從而改使用新的IPv6位置進行連線。</p>
<h3 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h3><p>(1) ssh登入Edgerouter後，<code>sudo vi /etc/ppp/ip-down.d/remove_invalidv6.sh</code> 貼上下列內容<br>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line">/sbin/ifconfig switch0 | grep -ivE <span class="string">'fe80'</span> | grep <span class="string">'inet6'</span> | awk <span class="string">'&#123;print $3&#125;'</span> | <span class="keyword">while</span> <span class="built_in">read</span> -r ipv6addr ; <span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"Removing <span class="variable">$ipv6addr</span> from switch0"</span> &gt;&gt; /tmp/ipv6_remove.log</div><div class="line">    /sbin/ip -6 addr del <span class="variable">$ipv6addr</span> dev switch0</div><div class="line"><span class="keyword">done</span></div><div class="line">/etc/init.d/radvd restart</div></pre></td></tr></table></figure></p>
<p>(2) 存擋離開後，輸入: <code>sudo chmod +x /etc/ppp/ip-down.d/remove_invalidv6.sh</code></p>
<p>(3) 修改此檔，<code>sudo vi /opt/vyatta/sbin/vyatta_gen_radvd.pl</code>，在243行會看到下列程式碼</p>
   <figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Write parameters out to config file</span></div><div class="line"><span class="keyword">print</span> $FD_WR <span class="string">"    prefix $prefix &#123;\n"</span>;</div><div class="line"><span class="keyword">foreach</span> <span class="keyword">my</span> $key (<span class="keyword">keys</span> %prefix_param_hash) &#123;</div><div class="line">    <span class="keyword">print</span> $FD_WR <span class="string">"        $key $prefix_param_hash&#123;$key&#125;;\n"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">print</span> $FD_WR <span class="string">"    &#125;;\n"</span>;</div></pre></td></tr></table></figure>
<p>  在倒數第二行, 新增一行code如下</p>
  <figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Write parameters out to config file</span></div><div class="line">  <span class="keyword">print</span> $FD_WR <span class="string">"    prefix $prefix &#123;\n"</span>;</div><div class="line">  <span class="keyword">foreach</span> <span class="keyword">my</span> $key (<span class="keyword">keys</span> %prefix_param_hash) &#123;</div><div class="line">      <span class="keyword">print</span> $FD_WR <span class="string">"        $key $prefix_param_hash&#123;$key&#125;;\n"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">print</span> $FD_WR <span class="string">"        DeprecatePrefix on;\n"</span>;  <span class="comment"># &lt;====================== 新增這一行!!</span></div><div class="line">  <span class="keyword">print</span> $FD_WR <span class="string">"    &#125;;\n"</span>;</div></pre></td></tr></table></figure>
<p>(4) 存擋離開後, 輸入<code>sudo reboot</code>重開機即可. </p>
<h3 id="小記"><a href="#小記" class="headerlink" title="小記"></a>小記</h3><p>這問題應該存在EdgeOS中很久了，在官方論壇中只看到有人問也沒人解，所以就自己跳下來解掉了。</p>
<p>此為官方論壇討論串：<a href="https://community.ubnt.com/t5/EdgeMAX/Solution-for-client-losing-IPv6-connectivity-after-PPPoE-re/m-p/2019416" target="_blank" rel="external">Solution for client losing IPv6 connectivity after PPPoE re-assign the new prefix</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;症狀&quot;&gt;&lt;a href=&quot;#症狀&quot; class=&quot;headerlink&quot; title=&quot;症狀&quot;&gt;&lt;/a&gt;症狀&lt;/h3&gt;&lt;p&gt;使用Hinet非固定制方案並且有申請IPv6 Dual Stack的使用者，透過Edgerouter當作分享器時，串在Edgerouter後的電腦如果長期不關機，會碰到當Hinet強制斷線時重撥後，這些電腦雖然可以取得新的IPv6位置，但卻喪失所有的IPv6連線能力。&lt;br&gt;
    
    </summary>
    
    
      <category term="Edgerouter" scheme="http://blog.clyang.net/tags/Edgerouter/"/>
    
      <category term="IPv6" scheme="http://blog.clyang.net/tags/IPv6/"/>
    
  </entry>
  
  <entry>
    <title>Hello World!</title>
    <link href="http://blog.clyang.net/2017/08/15/Hello-World/"/>
    <id>http://blog.clyang.net/2017/08/15/Hello-World/</id>
    <published>2017-08-15T19:22:00.000Z</published>
    <updated>2017-08-18T12:28:10.324Z</updated>
    
    <content type="html"><![CDATA[<p>已經忘記是第幾次嘗試寫blog了 XD，希望這次可以撐久一點 kerker</p>
<p>(BTW，擺在github pages上面，所以沒有enable https.)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已經忘記是第幾次嘗試寫blog了 XD，希望這次可以撐久一點 kerker&lt;/p&gt;
&lt;p&gt;(BTW，擺在github pages上面，所以沒有enable https.)&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
</feed>
